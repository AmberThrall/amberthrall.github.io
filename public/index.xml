<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Amber Thrall</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Amber Thrall</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Apr 2025 11:59:38 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Contact</title>
      <link>http://localhost:1313/contact/</link>
      <pubDate>Tue, 15 Apr 2025 11:59:38 -0700</pubDate>
      <guid>http://localhost:1313/contact/</guid>
      <description>&lt;p&gt;The best way to contact me is via email:&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;amber.thrall AT wsu DOT edu&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Projects</title>
      <link>http://localhost:1313/projects/</link>
      <pubDate>Tue, 15 Apr 2025 11:54:36 -0700</pubDate>
      <guid>http://localhost:1313/projects/</guid>
      <description>&lt;p&gt;Below is a select collection of projects I&amp;rsquo;ve worked on.&#xA;More projects can be viewed on my GitHub page: &lt;a href=&#34;https://github.com/AmberThrall/&#34;&gt;https://github.com/AmberThrall/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;linear&#34;&gt;Linear&lt;/h3&gt;&#xA;&lt;p&gt;Linear is a C++14 linear algebra all-header library with built-in support for various matrix decomposition algorithms, including: QR, SVD, Schur, and more.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/AmberThrall/Linear&#34;&gt;https://github.com/AmberThrall/Linear&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;scomplex&#34;&gt;scomplex&lt;/h3&gt;&#xA;&lt;p&gt;Simplicial complex construction library written in Rust.&#xA;Supports typically used methods for topologically classifying data sets, including, complex construction via Vietoris-Rips and computation of Betti numbers.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Research</title>
      <link>http://localhost:1313/research/</link>
      <pubDate>Tue, 15 Apr 2025 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/research/</guid>
      <description>&lt;h2 id=&#34;computational-topology&#34;&gt;Computational Topology&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/1906.08256&#34;&gt;Steinhaus Filtration and Stable Paths in the Mapper&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We define a new filtration called the Steinhaus filtration built from a single cover based on a generalized Steinhaus distance, a generalization of Jaccard distance.&#xA;The homology persistence module of a Steinhaus filtration with infinitely many cover elements may not be $q$-tame, even when the covers are in a totally bounded space.&#xA;While this may pose a challenge to derive stability results, we show that the Steinhaus filtration is stable when the cover is finite.&lt;/p&gt;</description>
    </item>
    <item>
      <title>About</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Tue, 15 Apr 2025 11:31:32 -0700</pubDate>
      <guid>http://localhost:1313/about/</guid>
      <description>&lt;p&gt;I am a mathematician and computer scientist interested in topological data analysis.&#xA;I am currently a Ph.D graduate student at Washington State University studying mathematics.&#xA;I received a bachelors of science in mathematics from University of Washington Bothell in 2018.&lt;/p&gt;&#xA;&lt;p&gt;This website serves as a portfolio showcasing select projects as well as hosting my writing on math and technology.&lt;/p&gt;&#xA;&lt;p&gt;A copy of my CV is available &lt;a href=&#34;http://localhost:1313/cv.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Markov chains and chaos</title>
      <link>http://localhost:1313/posts/markov_chains_chaos/</link>
      <pubDate>Tue, 28 Nov 2023 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/markov_chains_chaos/</guid>
      <description>&lt;p&gt;In my &lt;a href=&#34;http://localhost:1313/posts/2xmod1&#34;&gt;previous post&lt;/a&gt;, we explored the dyadic transformation $x_{n+1}=2x_n\bmod1$ on [0,1). We found its behavior was dependent on whether $x_0$ was rational or irrational. We also found if we repeatedly applyed the map to an initial set of particles, its density converged towards the uniform density.&lt;/p&gt;&#xA;&lt;p&gt;Lets modify our map. Namely, on [0,1/2) we alter our map to be non-linear.&#xA;&lt;/p&gt;&#xA;$$&#xA;    x_{n+1} = \begin{cases}&#xA;        x_n + 2^\alpha x_n^{1+\alpha} &amp; 0\le x_n&lt;1/2 \\&#xA;        2x_n - 1 &amp; 1/2\le x_n&lt;1&#xA;    \end{cases}&#xA;$$&lt;p&gt;&#xA;where $\alpha\in[0,1]$ is some parameter controlling the concavity. Herein we refer to this map as the $\alpha$-map.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A simple example of chaos in 1D</title>
      <link>http://localhost:1313/posts/2xmod1/</link>
      <pubDate>Tue, 03 Oct 2023 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/2xmod1/</guid>
      <description>&lt;p&gt;In Nonlinear Dynamics and Chaos by Steven Strogatz, the following definition of chaos is given:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Chaos&lt;/strong&gt; is aperiodic long-term behavior in a deterministic system that exhibits sensitive dependence on initial conditions. (Strogatz, p. 331)&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;the-dyadic-transformation&#34;&gt;The Dyadic Transformation&lt;/h2&gt;&#xA;&lt;p&gt;On $[0,1)$ define the recurrence relation&lt;/p&gt;&#xA;$$&#xA;x_{n+1} = 2x_n\bmod1 = \begin{cases}&#xA;    2x_n &amp; x_n &lt; 1/2 \\&#xA;    2x_n-1 &amp; x_n \ge 1/2&#xA;\end{cases}.&#xA;$$&lt;p&gt;The above relation forms a discrete dynamical system on the space $[0,1)$. Consider the following graph of an orbit.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Building a software renderer</title>
      <link>http://localhost:1313/posts/tinysr/</link>
      <pubDate>Wed, 05 Jul 2023 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/tinysr/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve used graphics libraries such as OpenGL in the past, but what was going on under the hood felt like magic to me. In order to investigate how it works I developed my own software renderer, &lt;strong&gt;tinysr&lt;/strong&gt;, in rust. The following is an overview of how the library works. Big thanks to Dmitry Sokolov&amp;rsquo;s written up guide at &lt;a href=&#34;https://github.com/ssloy/tinyrenderer/wiki&#34;&gt;https://github.com/ssloy/tinyrenderer/wiki&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h1 id=&#34;shader-pipeline&#34;&gt;Shader Pipeline&lt;/h1&gt;&#xA;&lt;p&gt;OpenGL, which tinysr mimics, describes the following rendering pipeline:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/OpenGL-2.0-Programmable-Shader-Pipeline.png&#34; alt=&#34;OpenGL 2.0 Programmable Shader Pipeline&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>How LR parsing works</title>
      <link>http://localhost:1313/posts/lr_parsing/</link>
      <pubDate>Thu, 07 Jul 2022 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/lr_parsing/</guid>
      <description>&lt;p&gt;Consider the grammar $G$ defined by the production rules below (we use $ to represent the end of input):&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;$S\rightarrow E$$&lt;/li&gt;&#xA;&lt;li&gt;$E\rightarrow E+T$&lt;/li&gt;&#xA;&lt;li&gt;$E\rightarrow T$&lt;/li&gt;&#xA;&lt;li&gt;$T\rightarrow 0$&lt;/li&gt;&#xA;&lt;li&gt;$T\rightarrow 1$&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;We want to generate a table we can reference to parse text in linear time. LR parsing gives us such a table.&lt;/p&gt;&#xA;&lt;p&gt;While parsing an input, for example &amp;ldquo;1+1&amp;rdquo;, we make use of two stacks: state stack and symbol stack.&lt;/p&gt;&#xA;&lt;h2 id=&#34;using-the-parse-table&#34;&gt;Using the parse table&lt;/h2&gt;&#xA;&lt;p&gt;The corresponding parse table for our grammar (we&amp;rsquo;ll see how it&amp;rsquo;s generated later) is as follows:&lt;/p&gt;</description>
    </item>
    <item>
      <title>A small entity component system</title>
      <link>http://localhost:1313/posts/ecs/</link>
      <pubDate>Sat, 21 May 2022 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/ecs/</guid>
      <description>&lt;p&gt;Imagine creating a game using an object oriented (OO) design. You may have a base class representing entities (&amp;ldquo;objects&amp;rdquo; placed throughout the world). Derived from entities you have several sub-classes representing various different behaviors.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/ecs_oo.png&#34; alt=&#34;Sample OO Design&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;As your game gets more and more complex, the more of a mess your class structure becomes. For example, consider the class structure drawn out above. If your team decided to create an important friendly NPC that was unkillable, major refactoring would be required. In otherwords, as time goes on, the harder adding new features to your game becomes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Interpreting a C-like language in Rust</title>
      <link>http://localhost:1313/posts/tinyc_rust/</link>
      <pubDate>Thu, 31 Mar 2022 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/tinyc_rust/</guid>
      <description>&lt;p&gt;Lately I&amp;rsquo;ve been learning the programming language rust. To challenge myself, I decided to create an interpreter for a small&#xA;C-like language called &amp;ldquo;Tiny-C&amp;rdquo;. I&amp;rsquo;m still quite new to rust, but I am happy with the end result. You can view the code on GitHub at: &lt;a href=&#34;https://github.com/AmberThrall/TinyC&#34;&gt;https://github.com/AmberThrall/TinyC&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;defining-the-language&#34;&gt;Defining the language&lt;/h2&gt;&#xA;&lt;p&gt;Before creating an interpreter for a language, we need to define how our language works and create a parser. I based the language&#xA;on &lt;a href=&#34;https://gist.github.com/KartikTalwar/3095780&#34;&gt;Marc Feeley&amp;rsquo;s &amp;ldquo;Tiny-C Compiler&amp;rdquo;&lt;/a&gt; I came across on GitHub. It supports if statements, if-else statements, while statements and do statements. While Feeley&amp;rsquo;s compiler only supports four binary operators (+, -, &amp;lt; and =), I decided to include 12 binary operators (+, -, *, /, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, ==, =, &amp;amp;&amp;amp; and ||). I&amp;rsquo;ve also included a single function &lt;code&gt;print&lt;/code&gt; built-in to the language which simply prints out the provided value to stdout.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prime number generation</title>
      <link>http://localhost:1313/posts/sieve_of_eratosthenes/</link>
      <pubDate>Tue, 18 Jan 2022 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/sieve_of_eratosthenes/</guid>
      <description>&lt;p&gt;A &lt;strong&gt;prime number&lt;/strong&gt; $n$ is an integer greater than 1 such that it&amp;rsquo;s only divisors are 1 and $n$. While this may seem like a uninteresting property, prime numbers turn out to be very important&#xA;to cryptography. Most cryptography implementations work by using the prime factors of large numbers, requiring the prime factors to decrypt the data.&lt;/p&gt;&#xA;&lt;p&gt;One interesting exercise is that in prime number generation. We will go over two methods, a slow brute force method, and a much faster algorithm known as &lt;strong&gt;sieve of Eratosthenes&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
