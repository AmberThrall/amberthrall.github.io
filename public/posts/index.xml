<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Amber Thrall</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Amber Thrall</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Nov 2023 11:37:09 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Markov chains and chaos</title>
      <link>http://localhost:1313/posts/markov_chains_chaos/</link>
      <pubDate>Tue, 28 Nov 2023 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/markov_chains_chaos/</guid>
      <description>&lt;p&gt;In my &lt;a href=&#34;http://localhost:1313/posts/2xmod1&#34; &gt;previous post&lt;/a&gt;, we explored the dyadic transformation $x_{n+1}=2x_n\bmod1$ on [0,1). We found its behavior was dependent on whether $x_0$ was rational or irrational. We also found if we repeatedly applyed the map to an initial set of particles, its density converged towards the uniform density.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s modify our map. Namely, on [0,1/2) we alter our map to be non-linear.&#xA;&lt;/p&gt;&#xA;$$&#xA;    x_{n+1} = \begin{cases}&#xA;        x_n + 2^\alpha x_n^{1+\alpha} &amp; 0\le x_n&lt;1/2 \\&#xA;        2x_n - 1 &amp; 1/2\le x_n&lt;1&#xA;    \end{cases}&#xA;$$&lt;p&gt;&#xA;where $\alpha\in[0,1]$ is some parameter controlling the concavity. Herein we refer to this map as the $\alpha$-map.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A simple example of chaos in 1D</title>
      <link>http://localhost:1313/posts/2xmod1/</link>
      <pubDate>Tue, 03 Oct 2023 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/2xmod1/</guid>
      <description>&lt;p&gt;In Nonlinear Dynamics and Chaos by Steven Strogatz, the following definition of chaos is given:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Chaos&lt;/strong&gt; is aperiodic long-term behavior in a deterministic system that exhibits sensitive dependence on initial conditions. (Strogatz, p. 331)&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;the-dyadic-transformation&#34;&gt;&#xA;  The Dyadic Transformation&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#the-dyadic-transformation&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;On $[0,1)$ define the recurrence relation&lt;/p&gt;&#xA;$$&#xA;x_{n+1} = 2x_n\bmod1 = \begin{cases}&#xA;    2x_n &amp; x_n &lt; 1/2 \\&#xA;    2x_n-1 &amp; x_n \ge 1/2&#xA;\end{cases}.&#xA;$$&lt;p&gt;The above relation forms a discrete dynamical system on the space $[0,1)$. Consider the following graph of an orbit.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Building a software renderer</title>
      <link>http://localhost:1313/posts/tinysr/</link>
      <pubDate>Wed, 05 Jul 2023 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/tinysr/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve used graphics libraries such as OpenGL in the past, but what was going on under the hood felt like magic to me. In order to investigate how it works I developed my own software renderer, &lt;strong&gt;tinysr&lt;/strong&gt;, in rust. The following is an overview of how the library works. Big thanks to Dmitry Sokolov&amp;rsquo;s written up guide at &lt;a href=&#34;https://github.com/ssloy/tinyrenderer/wiki&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/ssloy/tinyrenderer/wiki&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h1 id=&#34;shader-pipeline&#34;&gt;&#xA;  Shader Pipeline&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#shader-pipeline&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;OpenGL, which tinysr mimics, describes the following rendering pipeline:&lt;/p&gt;</description>
    </item>
    <item>
      <title>How LR parsing works</title>
      <link>http://localhost:1313/posts/lr_parsing/</link>
      <pubDate>Thu, 07 Jul 2022 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/lr_parsing/</guid>
      <description>&lt;p&gt;Consider the grammar $G$ defined by the production rules below (we use $ to represent the end of input):&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;$S\rightarrow E$$&lt;/li&gt;&#xA;&lt;li&gt;$E\rightarrow E+T$&lt;/li&gt;&#xA;&lt;li&gt;$E\rightarrow T$&lt;/li&gt;&#xA;&lt;li&gt;$T\rightarrow 0$&lt;/li&gt;&#xA;&lt;li&gt;$T\rightarrow 1$&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;We want to generate a table we can reference to parse text in linear time. LR parsing gives us such a table.&lt;/p&gt;&#xA;&lt;p&gt;While parsing an input, for example &amp;ldquo;1+1&amp;rdquo;, we make use of two stacks: state stack and symbol stack.&lt;/p&gt;&#xA;&lt;h2 id=&#34;using-the-parse-table&#34;&gt;&#xA;  Using the parse table&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#using-the-parse-table&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;The corresponding parse table for our grammar (we&amp;rsquo;ll see how it&amp;rsquo;s generated later) is as follows:&lt;/p&gt;</description>
    </item>
    <item>
      <title>A small entity component system</title>
      <link>http://localhost:1313/posts/ecs/</link>
      <pubDate>Sat, 21 May 2022 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/ecs/</guid>
      <description>&lt;p&gt;Imagine creating a game using an object oriented (OO) design. You may have a base class representing entities (&amp;ldquo;objects&amp;rdquo; placed throughout the world). Derived from entities you have several sub-classes representing various different behaviors.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/ecs_oo.png&#34; alt=&#34;Sample OO Design&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;As your game gets more and more complex, the more of a mess your class structure becomes. For example, consider the class structure drawn out above. If your team decided to create an important friendly NPC that was unkillable, major refactoring would be required. In otherwords, as time goes on, the harder adding new features to your game becomes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Interpreting a C-like language in Rust</title>
      <link>http://localhost:1313/posts/tinyc_rust/</link>
      <pubDate>Thu, 31 Mar 2022 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/tinyc_rust/</guid>
      <description>&lt;p&gt;Lately I&amp;rsquo;ve been learning the programming language rust. To challenge myself, I decided to create an interpreter for a small&#xA;C-like language called &amp;ldquo;Tiny-C&amp;rdquo;. I&amp;rsquo;m still quite new to rust, but I am happy with the end result. You can view the code on GitHub at: &lt;a href=&#34;https://github.com/AmberThrall/TinyC&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/AmberThrall/TinyC&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;defining-the-language&#34;&gt;&#xA;  Defining the language&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#defining-the-language&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Before creating an interpreter for a language, we need to define how our language works and create a parser. I based the language&#xA;on &lt;a href=&#34;https://gist.github.com/KartikTalwar/3095780&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Marc Feeley&amp;rsquo;s &amp;ldquo;Tiny-C Compiler&amp;rdquo;&lt;/a&gt; I came across on GitHub. It supports if statements, if-else statements, while statements and do statements. While Feeley&amp;rsquo;s compiler only supports four binary operators (+, -, &amp;lt; and =), I decided to include 12 binary operators (+, -, *, /, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, ==, =, &amp;amp;&amp;amp; and ||). I&amp;rsquo;ve also included a single function &lt;code&gt;print&lt;/code&gt; built-in to the language which simply prints out the provided value to stdout.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prime number generation</title>
      <link>http://localhost:1313/posts/sieve_of_eratosthenes/</link>
      <pubDate>Tue, 18 Jan 2022 11:37:09 -0700</pubDate>
      <guid>http://localhost:1313/posts/sieve_of_eratosthenes/</guid>
      <description>&lt;p&gt;A &lt;strong&gt;prime number&lt;/strong&gt; $n$ is an integer greater than 1 such that it&amp;rsquo;s only divisors are 1 and $n$. While this may seem like a uninteresting property, prime numbers turn out to be very important&#xA;to cryptography. Most cryptography implementations work by using the prime factors of large numbers, requiring the prime factors to decrypt the data.&lt;/p&gt;&#xA;&lt;p&gt;One interesting exercise is that in prime number generation. We will go over two methods, a slow brute force method, and a much faster algorithm known as &lt;strong&gt;sieve of Eratosthenes&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
