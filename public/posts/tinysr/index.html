<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  Building a software renderer · Amber Thrall
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Amber Thrall">
<meta name="description" content="I&rsquo;ve used graphics libraries such as OpenGL in the past, but what was going on under the hood felt like magic to me. In order to investigate how it works I developed my own software renderer, tinysr, in rust. The following is an overview of how the library works. Big thanks to Dmitry Sokolov&rsquo;s written up guide at https://github.com/ssloy/tinyrenderer/wiki.

  Shader Pipeline
  
    
    Link to heading
  

OpenGL, which tinysr mimics, describes the following rendering pipeline:">
<meta name="keywords" content="">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Building a software renderer">
  <meta name="twitter:description" content="I’ve used graphics libraries such as OpenGL in the past, but what was going on under the hood felt like magic to me. In order to investigate how it works I developed my own software renderer, tinysr, in rust. The following is an overview of how the library works. Big thanks to Dmitry Sokolov’s written up guide at https://github.com/ssloy/tinyrenderer/wiki.
Shader Pipeline Link to heading OpenGL, which tinysr mimics, describes the following rendering pipeline:">

<meta property="og:url" content="http://localhost:1313/posts/tinysr/">
  <meta property="og:site_name" content="Amber Thrall">
  <meta property="og:title" content="Building a software renderer">
  <meta property="og:description" content="I’ve used graphics libraries such as OpenGL in the past, but what was going on under the hood felt like magic to me. In order to investigate how it works I developed my own software renderer, tinysr, in rust. The following is an overview of how the library works. Big thanks to Dmitry Sokolov’s written up guide at https://github.com/ssloy/tinyrenderer/wiki.
Shader Pipeline Link to heading OpenGL, which tinysr mimics, describes the following rendering pipeline:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-05T11:37:09-07:00">
    <meta property="article:modified_time" content="2023-07-05T11:37:09-07:00">




<link rel="canonical" href="http://localhost:1313/posts/tinysr/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.css" media="screen">
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-dark">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      Amber Thrall
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/research/">Research</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/projects/">Projects</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/contact/">Contact Me</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Blog</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/tinysr/">
              Building a software renderer
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2023-07-05T11:37:09-07:00">
                July 5, 2023
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              7-minute read
            </span>
          </div>
          
          
          
        </div>
      </header>

      <div class="post-content">
        
        <p>I&rsquo;ve used graphics libraries such as OpenGL in the past, but what was going on under the hood felt like magic to me. In order to investigate how it works I developed my own software renderer, <strong>tinysr</strong>, in rust. The following is an overview of how the library works. Big thanks to Dmitry Sokolov&rsquo;s written up guide at <a href="https://github.com/ssloy/tinyrenderer/wiki"  class="external-link" target="_blank" rel="noopener">https://github.com/ssloy/tinyrenderer/wiki</a>.</p>
<h1 id="shader-pipeline">
  Shader Pipeline
  <a class="heading-link" href="#shader-pipeline">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>OpenGL, which tinysr mimics, describes the following rendering pipeline:</p>
<p><img src="/images/OpenGL-2.0-Programmable-Shader-Pipeline.png" alt="OpenGL 2.0 Programmable Shader Pipeline"></p>
<p>We&rsquo;ll be skipping over some steps, but we are interested in the vertex shader and fragment shader steps. For each vertex we draw, we transform the vertex first by calling the pipeline&rsquo;s vertex shader. Then in the rasterization step, we execute the fragment shader to get the specific pixel color. For now our pipeline can be represented by the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">struct</span> <span style="color:#f0883e;font-weight:bold">Pipeline</span>;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#ff7b72">impl</span><span style="color:#6e7681"> </span>Program<span style="color:#6e7681"> </span><span style="color:#ff7b72">for</span><span style="color:#6e7681"> </span>Pipeline<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">type</span> <span style="color:#f0883e;font-weight:bold">Vertex</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[<span style="color:#ff7b72">f32</span>;<span style="color:#a5d6ff">3</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">fn</span> <span style="color:#d2a8ff;font-weight:bold">vertex</span>(<span style="color:#ff7b72;font-weight:bold">&amp;</span>self,<span style="color:#6e7681"> </span>v: <span style="color:#79c0ff">&amp;</span><span style="color:#f0883e;font-weight:bold">Self</span>::Vertex,<span style="color:#6e7681"> </span>position: <span style="color:#79c0ff">&amp;</span><span style="color:#f0883e;font-weight:bold">mut</span><span style="color:#6e7681"> </span>[<span style="color:#ff7b72">f32</span>;<span style="color:#a5d6ff">4</span>])<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72;font-weight:bold">*</span>position<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[v[<span style="color:#a5d6ff">0</span>],<span style="color:#6e7681"> </span>v[<span style="color:#a5d6ff">1</span>],<span style="color:#6e7681"> </span>v[<span style="color:#a5d6ff">2</span>],<span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">fn</span> <span style="color:#d2a8ff;font-weight:bold">fragment</span>(<span style="color:#ff7b72;font-weight:bold">&amp;</span>self,<span style="color:#6e7681"> </span>color: <span style="color:#79c0ff">&amp;</span><span style="color:#f0883e;font-weight:bold">mut</span><span style="color:#6e7681"> </span>[<span style="color:#ff7b72">f32</span>;<span style="color:#a5d6ff">4</span>])<span style="color:#6e7681"> </span>-&gt; <span style="color:#f0883e;font-weight:bold">Fragment</span><span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72;font-weight:bold">*</span>color<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[<span style="color:#a5d6ff">1.0</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>Fragment::Keep<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>}<span style="color:#6e7681">
</span></span></span></code></pre></div><p>tinysr is designed to have no dependencies, thus need to know what format vertex data is being provided. This is represented via the type <code>Vertex</code> in the <code>Program</code> trait.</p>
<p>Note that, like OpenGL, the vertex shader uses <strong>homogenous</strong> coordinates. This is common in computer graphics to allow us to perform various transformations using 4-by-4 matrices. This will be important if we want our users to use projection transformations. To convert our 4d vector into $\mathbb{R}^3$, we scale the first three coordinates by the forth. In other words, $(x,y,z,w)\rightarrow(x/w,y/w,z/w)$.</p>
<p>With this pipeline, the goal is create a set of vertex data and run the pipeline.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>tinysr<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>TinySR::default();<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>tinysr.set_viewport(<span style="color:#a5d6ff">0</span>,<span style="color:#a5d6ff">0</span>,<span style="color:#6e7681"> </span><span style="color:#79c0ff;font-weight:bold">WIDTH</span>,<span style="color:#79c0ff;font-weight:bold">HEIGHT</span>);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>shader<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>Shader;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>vertices<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>vec![<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//  X     Y    Z
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#6e7681">    </span>[<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">0.5</span>,<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">0.5</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>],<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>[<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.5</span>,<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">0.5</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>],<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>[<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>,<span style="color:#6e7681">  </span><span style="color:#a5d6ff">0.5</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>],<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>tinysr.draw_array::<span style="color:#ff7b72;font-weight:bold">&lt;</span>Points,_<span style="color:#ff7b72;font-weight:bold">&gt;</span>(<span style="color:#ff7b72;font-weight:bold">&amp;</span>shader,<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&amp;</span>vertices);<span style="color:#6e7681">
</span></span></span></code></pre></div><p>For the vertices&rsquo; position data we use <strong>normalized device-coordinates</strong> (NDC) for position data. Using NDC simplifies rendering for the user. For our image we have a pixel grid $(0,0)\times(w,h)$ but don&rsquo;t want our end-user to have to worry about transforming data to their desired viewport. Thus the user provides data in NDC where items on the screen lie in $(-1,-1)\times(1,1)$. Sometimes the space using NDC is called <strong>clip-space</strong> as opposed to <strong>screen-space</strong>. Before we draw to the screen we can simply convert between spaces.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">pub</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">fn</span> <span style="color:#d2a8ff;font-weight:bold">conv_ndc_coords</span>(<span style="color:#ff7b72;font-weight:bold">&amp;</span>self,<span style="color:#6e7681"> </span>x: <span style="color:#ff7b72">f32</span>,<span style="color:#6e7681"> </span>y: <span style="color:#ff7b72">f32</span>)<span style="color:#6e7681"> </span>-&gt; [<span style="color:#ff7b72">i32</span>;<span style="color:#a5d6ff">2</span>]<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>x<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>(self.viewport.size[<span style="color:#a5d6ff">0</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72">as</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">f32</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">/</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">2.0</span>)<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">*</span><span style="color:#6e7681"> </span>(x<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span>)<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>self.viewport.origin[<span style="color:#a5d6ff">0</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72">as</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">f32</span>;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>y<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>(self.viewport.size[<span style="color:#a5d6ff">1</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72">as</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">f32</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">/</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">2.0</span>)<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">*</span><span style="color:#6e7681"> </span>(y<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span>)<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>self.viewport.origin[<span style="color:#a5d6ff">1</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72">as</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">f32</span>;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>[x<span style="color:#6e7681"> </span><span style="color:#ff7b72">as</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">i32</span>,<span style="color:#6e7681"> </span>y<span style="color:#6e7681"> </span><span style="color:#ff7b72">as</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">i32</span>]<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>}<span style="color:#6e7681">
</span></span></span></code></pre></div><p>With our vertex data in NDC we can use the <code>draw_array</code> method which takes in the shader pipeline and vertex data and passes the data into the rasterization algorithm handled by a <code>Primitive</code> trait, in this case <code>Points</code> which simply draws a pixel at each vertex.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">pub</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">struct</span> <span style="color:#f0883e;font-weight:bold">Points</span>;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#ff7b72">impl</span><span style="color:#6e7681"> </span>Primitive<span style="color:#6e7681"> </span><span style="color:#ff7b72">for</span><span style="color:#6e7681"> </span>Points<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">fn</span> <span style="color:#d2a8ff;font-weight:bold">draw</span><span style="color:#ff7b72;font-weight:bold">&lt;</span>P: <span style="color:#f0883e;font-weight:bold">Program</span><span style="color:#ff7b72;font-weight:bold">&gt;</span>(program: <span style="color:#79c0ff">&amp;</span><span style="color:#f0883e;font-weight:bold">P</span>,<span style="color:#6e7681"> </span>vertices: <span style="color:#79c0ff">&amp;</span>[<span style="color:#ff7b72;font-weight:bold">&amp;</span>P::Vertex],<span style="color:#6e7681"> </span>target: <span style="color:#79c0ff">&amp;</span><span style="color:#f0883e;font-weight:bold">mut</span><span style="color:#6e7681"> </span>ScreenBuffer)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">for</span><span style="color:#6e7681"> </span>vertex<span style="color:#6e7681"> </span><span style="color:#ff7b72">in</span><span style="color:#6e7681"> </span>vertices<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>trans_v<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[<span style="color:#a5d6ff">0.0</span>;<span style="color:#a5d6ff">4</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span>program.vertex(vertex,<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&amp;</span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>trans_v);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>color<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[<span style="color:#a5d6ff">0.0</span>;<span style="color:#a5d6ff">4</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>discard<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>program.fragment(vert_out,<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&amp;</span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>color);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>discard<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">==</span><span style="color:#6e7681"> </span>Fragment::Keep<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span>target.draw_ndc(trans_v[<span style="color:#a5d6ff">0</span>]<span style="color:#ff7b72;font-weight:bold">/</span>trans_v[<span style="color:#a5d6ff">3</span>],<span style="color:#6e7681"> </span>trans_v[<span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">/</span>trans_v[<span style="color:#a5d6ff">3</span>],<span style="color:#6e7681"> </span>color);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>}<span style="color:#6e7681">
</span></span></span></code></pre></div><p>Resulting in the following:</p>
<p><img src="/images/tinysr_points.png" alt="3 white pixels"></p>
<h1 id="drawing-triangles">
  Drawing Triangles
  <a class="heading-link" href="#drawing-triangles">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>With the framework setup, it is time to actually draw something interesting. Luckily, drawing triangles turns out to be quite simple. We can simply iterate through each pixel, if the pixel is inside the triangle then we draw the pixel. To optimize this, we can only check pixels within a bounding box of the triangle.</p>
<p>Consider the following algorithm taking in 3 points in screen coordiantes:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>bbox<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>create_bounding_box(a,b,c);<span style="color:#6e7681"> </span><span style="color:#8b949e;font-style:italic">// a,b,c are the three vertices in screen space.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">for</span><span style="color:#6e7681"> </span>x<span style="color:#6e7681"> </span><span style="color:#ff7b72">in</span><span style="color:#6e7681"> </span>bbox.min[<span style="color:#a5d6ff">0</span>]<span style="color:#ff7b72;font-weight:bold">..=</span>bbox.max[<span style="color:#a5d6ff">0</span>]<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">for</span><span style="color:#6e7681"> </span>y<span style="color:#6e7681"> </span><span style="color:#ff7b72">in</span><span style="color:#6e7681"> </span>bbox.min[<span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">..=</span>bbox.max[<span style="color:#a5d6ff">1</span>]<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>is_point_in_triangle(a,<span style="color:#6e7681"> </span>b,<span style="color:#6e7681"> </span>c,<span style="color:#6e7681"> </span>[x,y])<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#8b949e;font-style:italic">// draw pixel at (x,y).
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#6e7681">        </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>}<span style="color:#6e7681">
</span></span></span></code></pre></div><p>Now the obvious question is how do we know if our point is inside the triangle? We can make use of <strong>barycentric coordinates</strong>. The Wikipedia article for barycentric coordinates is very abstract and unhelpful for us. For our application, barycentric coordinates provide a way to represent a point as a weighted sum of the triangle&rsquo;s vertices. For a triangle $ABC$ and point $P$, we want weights $\alpha,\beta,\gamma$ such that $P=\alpha A + \beta B + \gamma C$ and $\alpha+\beta+\gamma=1$. With this, as long as all three weights are non-negative the point lies within the triangle.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">fn</span> <span style="color:#d2a8ff;font-weight:bold">is_point_in_triangle</span>(a: [<span style="color:#ff7b72">i32</span>;<span style="color:#a5d6ff">2</span>],<span style="color:#6e7681"> </span>b: [<span style="color:#ff7b72">i32</span>;<span style="color:#a5d6ff">2</span>],<span style="color:#6e7681"> </span>c: [<span style="color:#ff7b72">i32</span>;<span style="color:#a5d6ff">2</span>],<span style="color:#6e7681"> </span>p: [<span style="color:#ff7b72">i32</span>;<span style="color:#a5d6ff">2</span>])<span style="color:#6e7681"> </span>-&gt; <span style="color:#ff7b72">bool</span> {<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">// calculate barycentric coords.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#6e7681">    </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>u1<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[c[<span style="color:#a5d6ff">0</span>]<span style="color:#ff7b72;font-weight:bold">-</span>a[<span style="color:#a5d6ff">0</span>],<span style="color:#6e7681"> </span>b[<span style="color:#a5d6ff">0</span>]<span style="color:#ff7b72;font-weight:bold">-</span>a[<span style="color:#a5d6ff">0</span>],<span style="color:#6e7681"> </span>a[<span style="color:#a5d6ff">0</span>]<span style="color:#ff7b72;font-weight:bold">-</span>p[<span style="color:#a5d6ff">0</span>]];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>u2<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[c[<span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">-</span>a[<span style="color:#a5d6ff">1</span>],<span style="color:#6e7681"> </span>b[<span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">-</span>a[<span style="color:#a5d6ff">1</span>],<span style="color:#6e7681"> </span>a[<span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">-</span>p[<span style="color:#a5d6ff">1</span>]];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>u<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>cross_product(u1,<span style="color:#6e7681"> </span>u2);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>bc<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>u[<span style="color:#a5d6ff">2</span>].abs()<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span><span style="color:#6e7681"> </span>{<span style="color:#6e7681"> 
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">return</span><span style="color:#6e7681"> </span>[<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1.0</span>,<span style="color:#a5d6ff">1.0</span>,<span style="color:#a5d6ff">1.0</span>];<span style="color:#6e7681">  </span><span style="color:#8b949e;font-style:italic">// Triangle is degenerate.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#6e7681">    </span>}<span style="color:#6e7681"> </span><span style="color:#ff7b72">else</span><span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>[<span style="color:#a5d6ff">1.0</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#6e7681"> </span>(u[<span style="color:#a5d6ff">0</span>]<span style="color:#ff7b72;font-weight:bold">+</span>u[<span style="color:#a5d6ff">1</span>])<span style="color:#ff7b72;font-weight:bold">/</span>u[<span style="color:#a5d6ff">2</span>],<span style="color:#6e7681"> </span>u[<span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">/</span>u[<span style="color:#a5d6ff">2</span>],<span style="color:#6e7681"> </span>u[<span style="color:#a5d6ff">0</span>]<span style="color:#ff7b72;font-weight:bold">/</span>u[<span style="color:#a5d6ff">2</span>]]<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">return</span><span style="color:#6e7681"> </span>bc[<span style="color:#a5d6ff">0</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&gt;=</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">0</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span><span style="color:#6e7681"> </span>bc[<span style="color:#a5d6ff">1</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&gt;=</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">0</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span><span style="color:#6e7681"> </span>bc[<span style="color:#a5d6ff">2</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&gt;=</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">0</span>;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>}<span style="color:#6e7681">
</span></span></span></code></pre></div><p>I&rsquo;ll skip over the math behind this function. If you are interested, you can assume $\gamma=(1-\alpha-\beta)$ leaving you with a two equations and two unknowns. The algebra becomes messy quite quickly.</p>
<p>With this, we can finally draw our triangle.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">fn</span> <span style="color:#d2a8ff;font-weight:bold">draw</span><span style="color:#ff7b72;font-weight:bold">&lt;</span>P: <span style="color:#f0883e;font-weight:bold">Program</span><span style="color:#ff7b72;font-weight:bold">&gt;</span>(program: <span style="color:#79c0ff">&amp;</span><span style="color:#f0883e;font-weight:bold">P</span>,<span style="color:#6e7681"> </span>vertices: <span style="color:#79c0ff">&amp;</span>[<span style="color:#ff7b72;font-weight:bold">&amp;</span>P::Vertex],<span style="color:#6e7681"> </span>target: <span style="color:#79c0ff">&amp;</span><span style="color:#f0883e;font-weight:bold">mut</span><span style="color:#6e7681"> </span>ScreenBuffer)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>ntris<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>vertices.len()<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">/</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">3</span>;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">for</span><span style="color:#6e7681"> </span>i<span style="color:#6e7681"> </span><span style="color:#ff7b72">in</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">0</span><span style="color:#ff7b72;font-weight:bold">..</span>ntris<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>pts<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>Vec::new();<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">for</span><span style="color:#6e7681"> </span>j<span style="color:#6e7681"> </span><span style="color:#ff7b72">in</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">0</span><span style="color:#ff7b72;font-weight:bold">..</span><span style="color:#a5d6ff">3</span><span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>pt<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[<span style="color:#a5d6ff">0.0</span>;<span style="color:#a5d6ff">4</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span>program.vertex(<span style="color:#ff7b72;font-weight:bold">&amp;</span>vertices[i<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">*</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">3</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>j],<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&amp;</span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>pt);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span>pts.push([pt[<span style="color:#a5d6ff">0</span>]<span style="color:#ff7b72;font-weight:bold">/</span>pt[<span style="color:#a5d6ff">3</span>],<span style="color:#6e7681"> </span>pt[<span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">/</span>pt[<span style="color:#a5d6ff">3</span>],<span style="color:#6e7681"> </span>pt[<span style="color:#a5d6ff">2</span>]<span style="color:#ff7b72;font-weight:bold">/</span>pt[<span style="color:#a5d6ff">3</span>]]);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">// convert the points to screen space and draw the triangle
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>}<span style="color:#6e7681">
</span></span></span></code></pre></div><p>Resulting in the following:</p>
<p><img src="/images/tinysr_triangle.png" alt="white triangle"></p>
<h1 id="extending-our-pipeline">
  Extending our Pipeline
  <a class="heading-link" href="#extending-our-pipeline">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>Right now the vertex shader and fragment shader can&rsquo;t communicate. If we want our fragment shader to do more than return a solid color, we need to find a way to bridge the two.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">impl</span><span style="color:#6e7681"> </span>Program<span style="color:#6e7681"> </span><span style="color:#ff7b72">for</span><span style="color:#6e7681"> </span>Shader<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">type</span> <span style="color:#f0883e;font-weight:bold">Vertex</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[<span style="color:#ff7b72">f32</span>;<span style="color:#a5d6ff">6</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">type</span> <span style="color:#f0883e;font-weight:bold">VertexOut</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[<span style="color:#ff7b72">f32</span>;<span style="color:#a5d6ff">3</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">fn</span> <span style="color:#d2a8ff;font-weight:bold">vertex</span>(<span style="color:#ff7b72;font-weight:bold">&amp;</span>self,<span style="color:#6e7681"> </span>v: <span style="color:#79c0ff">&amp;</span><span style="color:#f0883e;font-weight:bold">Self</span>::Vertex,<span style="color:#6e7681"> </span>position: <span style="color:#79c0ff">&amp;</span><span style="color:#f0883e;font-weight:bold">mut</span><span style="color:#6e7681"> </span>[<span style="color:#ff7b72">f32</span>;<span style="color:#a5d6ff">4</span>])<span style="color:#6e7681"> </span>-&gt; <span style="color:#f0883e;font-weight:bold">Self</span>::VertexOut<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72;font-weight:bold">*</span>position<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[v[<span style="color:#a5d6ff">0</span>],<span style="color:#6e7681"> </span>v[<span style="color:#a5d6ff">1</span>],<span style="color:#6e7681"> </span>v[<span style="color:#a5d6ff">2</span>],<span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>[v[<span style="color:#a5d6ff">3</span>],v[<span style="color:#a5d6ff">4</span>],v[<span style="color:#a5d6ff">5</span>]]<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">fn</span> <span style="color:#d2a8ff;font-weight:bold">fragment</span>(<span style="color:#ff7b72;font-weight:bold">&amp;</span>self,<span style="color:#6e7681"> </span>v: <span style="color:#f0883e;font-weight:bold">Self</span>::VertexOut,<span style="color:#6e7681"> </span>color: <span style="color:#79c0ff">&amp;</span><span style="color:#f0883e;font-weight:bold">mut</span><span style="color:#6e7681"> </span>[<span style="color:#ff7b72">f32</span>;<span style="color:#a5d6ff">4</span>])<span style="color:#6e7681"> </span>-&gt; <span style="color:#f0883e;font-weight:bold">Fragment</span><span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72;font-weight:bold">*</span>color<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[v[<span style="color:#a5d6ff">0</span>],<span style="color:#6e7681"> </span>v[<span style="color:#a5d6ff">1</span>],<span style="color:#6e7681"> </span>v[<span style="color:#a5d6ff">2</span>],<span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>Fragment::Keep<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>}<span style="color:#6e7681">
</span></span></span></code></pre></div><p>Now our vertex data includes vertex color.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>vertices<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>vec![<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//  X     Y    Z      R    G    B
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#6e7681">    </span>[<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">0.5</span>,<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">0.5</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>,<span style="color:#6e7681">   </span><span style="color:#a5d6ff">1.0</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>],<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>[<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.5</span>,<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">0.5</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>,<span style="color:#6e7681">   </span><span style="color:#a5d6ff">0.0</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>],<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>[<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>,<span style="color:#6e7681">  </span><span style="color:#a5d6ff">0.5</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>,<span style="color:#6e7681">   </span><span style="color:#a5d6ff">0.0</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">0.0</span>,<span style="color:#6e7681"> </span><span style="color:#a5d6ff">1.0</span>],<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>];<span style="color:#6e7681">
</span></span></span></code></pre></div><p>In order to get our new pipeline working, there&rsquo;s one slight problem to tackle first. The pipeline runs the vertex shader once per vertex, but the fragment shader once per pixel. What vertex data is passed to what fragment?</p>
<p>The answer is all of them! More specifically, we linearly interpolate the values of <code>VertexOut</code> between all vertices for each pixel. To get this working in rust I added an <code>Interpolate</code> trait which takes in $N$ values and $N$ weights and returns a new value. We then require the type <code>VertexOut</code> in our pipeline to implement the <code>Interploate</code> trait.</p>
<p>Now when we run the vertex shader we store the output along with the position data and use them when we run the fragment shader. Below is the triangle primitive taking advantage of this using our barycentric coordinates as weights.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span>data_interp<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>P::VertexOut::interpolate(<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72;font-weight:bold">&amp;</span>[a_data.clone(),<span style="color:#6e7681"> </span>b_data.clone(),<span style="color:#6e7681"> </span>c_data.clone()],<span style="color:#6e7681"> 
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72;font-weight:bold">&amp;</span>bc<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>color<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>[<span style="color:#a5d6ff">0.0</span>;<span style="color:#a5d6ff">4</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>program.fragment(data_interp,<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&amp;</span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>color)<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">==</span><span style="color:#6e7681"> </span>Fragment::Keep<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>target.draw(x,<span style="color:#6e7681"> </span>y,<span style="color:#6e7681"> </span>color);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>}<span style="color:#6e7681">
</span></span></span></code></pre></div><p>Now our triangle is fully colored!</p>
<p><img src="/images/tinysr_triangle2.png" alt="colored triangle"></p>
<h1 id="adding-depth">
  Adding Depth
  <a class="heading-link" href="#adding-depth">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>Right now our renderer has a race-condition problem. If a triangle in the back is drawn after one in the front, the wrong triangle will be drawn. We see this in action when trying to draw a more complex model such as a teapot:</p>
<p><img src="/images/teapot_no_zbuffer.png" alt="teapot without zbuffer"></p>
<p>We can correct this with a <strong>z-buffer</strong>. A z-buffer is a simple concept. When we draw a pixel to the screen, we record it&rsquo;s z-value, i.e., it&rsquo;s depth. If the current pixel&rsquo;s z-value is greater than what we are trying to render than we stop drawing that pixel. We just have to remember to reset each pixel of the z-buffer to $-\infty$ before we start drawing.</p>
<p>This requires a slight alteration to our triangle drawing. We now need to pass in a z-value and use our barycentric coordinates to calculate the z-value of each pixel.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff7b72">let</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">mut</span><span style="color:#6e7681"> </span>z<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>a[<span style="color:#a5d6ff">2</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">*</span><span style="color:#6e7681"> </span>bc[<span style="color:#a5d6ff">0</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>b[<span style="color:#a5d6ff">2</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">*</span><span style="color:#6e7681"> </span>bc[<span style="color:#a5d6ff">1</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>c[<span style="color:#a5d6ff">2</span>]<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">*</span><span style="color:#6e7681"> </span>bc[<span style="color:#a5d6ff">2</span>];<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>target.write_zbuffer(x,<span style="color:#6e7681"> </span>y,<span style="color:#6e7681"> </span>z)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">// draw the pixel
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}<span style="color:#6e7681">
</span></span></span></code></pre></div><p>The method <code>write_zbuffer</code> above attempts to write to the z-buffer. If a greater z-value is present, the method stops and returns false. Otherwise it updates the z-buffer and returns true.</p>
<p>With this simple adjustment our teapot is now rendering correctly!</p>
<p><img src="/images/teapot_w_zbuffer.png" alt="teapot with zbuffer"></p>
<p>The full code can be seen on GitHub at: <a href="https://github.com/AmberThrall/tinysr/"  class="external-link" target="_blank" rel="noopener">https://github.com/AmberThrall/tinysr/</a></p>

      </div>


      <footer>
        


        
        
        
        
        
        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2025
     Amber Thrall 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>
</html>
